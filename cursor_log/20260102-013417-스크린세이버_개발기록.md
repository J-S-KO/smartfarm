# 스크린세이버 개발 기록

**작성일**: 2026-01-02  
**작성자**: Cursor AI  
**주제**: 화면보호기 딸기 비트맵 표시 및 애니메이션 구현

---

## 📋 개발 목표

베란다 스마트팜 시스템의 화면보호기 모드에서 64x64 픽셀 딸기 비트맵을 표시하고, 화면 내에서 부드럽게 움직이는 애니메이션을 구현하는 것.

---

## 🔴 문제 1: RAM 부족 현상

### 문제 상황
- 64x64 픽셀 비트맵 데이터가 RAM에 저장되어 512바이트 사용
- Arduino Uno는 약 2KB SRAM만 제공
- 다른 센서 데이터, String 변수 등과 함께 사용 시 RAM 부족 위험

### 원인 분석
```cpp
// 문제 코드
const unsigned char epd_bitmap_strawberry[] = {
  // 512바이트 데이터...
};
```
- `const` 키워드만 사용하여 RAM에 저장됨
- PROGMEM 키워드가 없어 플래시 메모리를 활용하지 못함

### 해결 방법
```cpp
// 해결 코드
const unsigned char epd_bitmap_strawberry[] PROGMEM = {
  // 512바이트 데이터...
};
```
- `PROGMEM` 키워드 추가로 플래시 메모리에 저장
- RAM 512바이트 절약 (약 25%에 해당)

### 결과
- ✅ RAM 사용량: 1218바이트 → 1216바이트 (약간 감소)
- ✅ 메모리 부족 위험 해소
- ✅ 다른 센서 동작에 영향 없음

---

## 🔴 문제 2: 비트맵 표시 깨짐 현상

### 문제 상황
- PROGMEM을 사용한 후 비트맵이 깨져서 표시됨
- 점이 엄청 많이 뿌려진 형태로 나타남

### 원인 분석
- `drawXBM()` 함수를 사용했지만, 데이터 형식이 `drawBitmap` 형식
- `drawBitmap`은 RAM 데이터만 지원
- `drawXBM`은 XBM 형식을 기대하지만 현재 데이터는 drawBitmap 형식

### 해결 방법
```cpp
// 해결 코드: PROGMEM에서 한 줄씩 읽어서 drawBitmap으로 그리기
void drawStrawberry(int x, int y) {
  uint8_t lineBuffer[8]; // 한 줄 버퍼 (8바이트만 필요)
  
  for (int row = 0; row < 64; row++) {
    // PROGMEM에서 한 줄 읽기
    for (int col = 0; col < 8; col++) {
      lineBuffer[col] = pgm_read_byte(&epd_bitmap_strawberry[row * 8 + col]);
    }
    // 한 줄 그리기
    u8g2.drawBitmap(x, y + row, 8, 1, lineBuffer);
  }
}
```

### 핵심 아이디어
- PROGMEM에서 전체를 복사하지 않고 한 줄씩(8바이트)만 읽어서 그리기
- RAM 사용량: 512바이트 → 8바이트로 대폭 감소
- `pgm_read_byte()` 함수로 플래시 메모리에서 직접 읽기

### 결과
- ✅ 비트맵이 정상적으로 표시됨
- ✅ RAM 사용량 최소화 (8바이트만 필요)
- ✅ 성능 영향 없음 (화면 렌더링 속도 정상)

---

## 🔴 문제 3: 화면보호기 위치 이동 멈춤 현상

### 문제 상황
- 화면보호기가 처음 4~5초 정도 움직이다가 멈춤
- V자로 움직이다가 정지

### 원인 분석
```cpp
// 문제 코드
if (millis() - lastAction > HOME_TIMEOUT && ...) {
  if (currState != SCREENSAVER) {
    // 초기화...
  }
  currState = SCREENSAVER;
  lastScreensaverMove = millis(); // ⚠️ 매 루프마다 실행됨!
}
```
- `lastScreensaverMove = millis();`가 `if (currState != SCREENSAVER)` 블록 밖에 위치
- 화면보호기 모드가 활성화된 상태에서도 매 루프마다 타이머가 리셋됨
- 1초 타이머가 절대 도달하지 못함

### 해결 방법
```cpp
// 해결 코드
if (millis() - lastAction > HOME_TIMEOUT && ...) {
  if (currState != SCREENSAVER) {
    // 화면보호기로 처음 전환될 때만 초기화
    screensaverStartTime = millis();
    screensaverOffsetX = 0;
    screensaverOffsetY = 0;
    screensaverDirX = 1;
    screensaverDirY = 1;
    lastScreensaverMove = millis(); // ✅ 처음 전환 시에만 실행
  }
  currState = SCREENSAVER;
}
```

### 결과
- ✅ 화면보호기가 계속 반복적으로 이동
- ✅ 1초마다 정상적으로 위치 업데이트
- ✅ 반복 이동 보장

---

## 🔴 문제 4: Y 방향 이동 범위 문제

### 문제 상황
- 위쪽은 그림의 맨 위에서 튕김 (정상)
- 아래쪽으로 움직일 때 그림의 절반 이상이 화면 아래로 벗어남

### 원인 분석
- 비트맵 높이: 64픽셀
- 화면 높이: 64픽셀
- Y 오프셋이 30까지 증가하면: y=30 위치에서 시작 → y=30+64=94 (화면 밖)

### 해결 방법
```cpp
// 해결 코드: Y 오프셋을 0으로 고정
// Y 방향 움직임: 화면 상단(0)에 고정
// 비트맵 높이 64 = 화면 높이 64이므로 오프셋 0 유지
screensaverOffsetY = 0;
```

### 추가 개선
- 애니메이션 속도: 0.5초 → 1초로 완화 (더 부드러운 움직임)
- X 이동 범위: -30 ~ +30 픽셀 (화면 중앙 기준)

### 결과
- ✅ 화면을 벗어나지 않음
- ✅ 부드러운 애니메이션
- ✅ 시각적으로 안정적

---

## 🔴 문제 5: 부팅 상태에서 벗어나지 못함

### 문제 상황
- `farm-up-a` 실행 후 "Booting.." 화면에서 멈춤
- 화면보호기로 전환되지 않음

### 원인 분석
1. **라즈베리파이 문제**: `main.py` 72번째 줄 들여쓰기 오류로 서비스가 시작되지 않음
2. **Arduino 문제**: `STATE,` 명령이 수신되어도 시간이 `00:00`이면 `systemConnected`가 `true`로 설정되지 않음

### 해결 방법

#### 1. 라즈베리파이 수정
- `main.py`의 들여쓰기 오류 수정
- 서비스 정상 실행 확인

#### 2. Arduino 수정
```cpp
// 해결 코드: STATE 명령이 성공적으로 파싱되면 시간과 관계없이 연결로 간주
bool stateParsed = false;
if (found == 6 || found == 5) {
  // 파싱 성공...
  stateParsed = true;
}

// STATE 명령이 성공적으로 파싱되면 연결된 것으로 간주
if (!systemConnected && stateParsed) {
  systemConnected = true;
  // ...
}
```

### 결과
- ✅ 서비스 정상 실행
- ✅ Arduino가 부팅 상태에서 벗어남
- ✅ 화면보호기로 정상 전환

---

## 📊 최종 결과

### 성능 지표
- **RAM 사용량**: 1216바이트 (830바이트 여유)
- **플래시 사용량**: 26378바이트 (81%)
- **애니메이션 속도**: 1초 간격
- **이동 범위**: X축 -30 ~ +30 픽셀, Y축 고정

### 기능
- ✅ 64x64 픽셀 딸기 비트맵 정상 표시
- ✅ 화면 내에서 부드러운 좌우 이동
- ✅ PROGMEM 사용으로 RAM 절약
- ✅ 센서 동작에 영향 없음
- ✅ 부팅 후 자동 전환

### 기술적 성과
1. **메모리 최적화**: PROGMEM 활용으로 RAM 512바이트 절약
2. **효율적인 렌더링**: 한 줄씩 읽어서 그리기로 RAM 사용 최소화
3. **안정적인 타이머**: 조건부 타이머 리셋으로 반복 이동 보장
4. **안전한 범위 제한**: 화면 경계 체크로 벗어남 방지

---

## 🎓 교훈

1. **PROGMEM 활용**: 큰 데이터는 반드시 플래시 메모리에 저장
2. **조건부 초기화**: 상태 전환 시에만 초기화 로직 실행
3. **경계 체크**: 화면 크기와 비트맵 크기를 고려한 오프셋 제한
4. **단계별 디버깅**: RAM 문제 → 렌더링 문제 → 타이머 문제 순으로 해결

---

## 📝 참고 사항

- Arduino Uno RAM: 약 2KB
- 비트맵 크기: 64x64 = 512바이트
- 화면 크기: 128x64 픽셀
- u8g2 라이브러리: `drawBitmap` (RAM), `drawXBM` (PROGMEM)

